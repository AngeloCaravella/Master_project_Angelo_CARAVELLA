% ===================================================================
% CHAPTER 3: The EV2Gym Simulation Framework
% ===================================================================
\chapter{An Enhanced V2G Simulation Framework for Robust Control}
\label{chap:ev2gym}

Developing, validating, and benchmarking advanced control algorithms for Vehicle-to-Grid (V2G) systems presents significant challenges. Real-world experimentation is often impractical due to high costs, logistical constraints, and potential risks to grid stability and vehicle hardware. A realistic, flexible, and standardized simulation environment is therefore essential. This thesis builds upon \textbf{EV2Gym}, an open-source simulator designed for V2G smart charging research \cite{orfanoudakis2024ev2gym}. The work presented here extends the original framework substantially, transforming it into a high-fidelity \textbf{digital twin} suitable not only for single-scenario optimization, but also for developing and rigorously evaluating \textbf{robust, generalist control agents}.

\noindent
The enhanced framework supports two complementary modes of experimentation: detailed analysis of agents specialized for a single environment, and a novel methodology for training and testing agents capable of generalizing across multiple diverse and unpredictable scenarios. This chapter presents the extended architecture, its data-driven models, and its evaluation capabilities, establishing the methodological foundation for subsequent chapters.

\section{Core Simulator Architecture}
The framework maintains the modular architecture of EV2Gym, which mirrors the key entities of a real-world V2G system. It is built on the OpenAI Gym (now Gymnasium) API, which provides a standardized agent-environment interface based on states, actions, and rewards \cite{brockman2016openai}.

\begin{figure}[H]
    \centering
   
    \includegraphics[width=0.8\linewidth]{Diagram_charge.png}
    \caption{Diagram of charging and discharging scheduling for EVs. \cite{Dou}.}
    \label{fig:rl_cahrg}
\end{figure}

The architecture consists of several interacting components:
\begin{itemize}
    \item \textbf{Charge Point Operator (CPO):} The central management component of the simulation, responsible for controlling the charging infrastructure and serving as the primary interface for the control algorithm (the DRL agent). The CPO aggregates system state information and dispatches control actions to individual chargers.
    \item \textbf{Chargers:} Digital representations of physical charging stations, configurable by type (AC/DC), maximum power, and efficiency. This enables simulation of heterogeneous charging infrastructures.
    \item \textbf{Power Transformers:} These components model the physical connection points to the grid, aggregating the electrical load from multiple chargers. They enforce the physical power limits of the local distribution network and can model inflexible base loads (e.g., buildings) and local renewable generation (e.g., solar panels).
    \item \textbf{Electric Vehicles (EVs):} Dynamic and autonomous agents, each defined by its battery capacity, power limits, current and desired energy levels, and specific arrival and departure times.
\end{itemize}

The simulation process follows a reproducible three-phase structure: (1) \textbf{Initialization} from a comprehensive YAML configuration file, (2) a discrete-time \textbf{Simulation Loop} where the agent interacts with the environment, and (3) a final \textbf{Evaluation and Visualization} phase that generates standardized performance metrics.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Unified Experimentation and Evaluation Workflow}

A key contribution of this thesis is the development of a unified and powerful experimentation workflow, orchestrated primarily by the \texttt{run\_experiments.py} script (with an interactive interface provided by \texttt{run\_interactive.py}). This approach replaces the previous fragmentation, offering a single platform to manage the entire lifecycle of training, benchmarking, and evaluation for V2G control agents. The workflow is designed to be both flexible for research and rigorous for evaluation, supporting the goal of developing both specialized and generalized agents.

\subsection{Orchestration and Execution Interfaces}

The \texttt{run\_experiments.py} script serves as the central hub for all experimentation. To ensure flexibility and reproducibility, the project offers two execution modes:

\begin{enumerate}
    \item \textbf{Interactive Mode (\texttt{run\_interactive.py}):} Provides a guided, step-by-step command-line interface, ideal for initial configuration, testing, and running single experiments. The user responds to successive prompts to select scenarios, algorithms, and training parameters.
    \item \textbf{Scripted/Batch Mode (\texttt{run\_experiments.py}):} Utilizes the \texttt{argparse} module to accept all configuration parameters (e.g., \texttt{--scenarios}, \texttt{--reward\_func}, \texttt{--training\_mode}) directly as command-line arguments. This mode is essential for automation, reproducibility, and running large batches of experiments on servers or high-performance computing systems.
\end{enumerate}

The key steps in the workflow include:

\begin{itemize}
    \item \textbf{Algorithm Selection:} The script dynamically defines the algorithms to be executed, which can include Deep Reinforcement Learning agents (e.g., SAC, DDPG+PER, TQC), classical optimization methods (Model Predictive Control), and heuristics (e.g., AFAP, ALAP).
    \item \textbf{Scenario and Reward Selection:} The user selects one or more \texttt{.yaml} configuration files and the desired reward function from the \texttt{reward.py} module.
    \item \textbf{Battery Calibration:} The option to run \texttt{Fit\_battery.py} is provided to calibrate the parameters of the battery degradation model, ensuring that simulations use the most up-to-date data.
\end{itemize}

\subsection {Scenario structure Yaml file}

The YAML (YAML Ain't Markup Language) configuration file serves as the foundational blueprint for defining a simulation experiment within the EV2Gym framework.
It is a powerful and indispensable tool for the systematic study of EV smart charging strategies. It provides a structured and transparent method for defining the physical, economic, and stochastic properties of the simulation environment. A thorough understanding and deliberate manipulation of these parameters are essential for formulating meaningful research questions, generating valid results, and drawing robust conclusions about the performance of various control algorithms.

\section{Core Simulation Parameters}

This primary section establishes the temporal boundaries and fundamental operational logic of the simulation.

\begin{description}
    \item[\texttt{\textbf{timescale}}] Defines the temporal granularity of a single simulation step, measured in minutes. This parameter is critical as it dictates the resolution of the control problem; a smaller timescale allows for finer control but increases computational complexity.
    \begin{lstlisting}
# Timescale in minutes per simulation step
timescale: 15 
    \end{lstlisting}

    \item[\texttt{\textbf{simulation\_length}}] Specifies the total duration of a single simulation episode, measured in the number of steps defined by \texttt{timescale}.
    \begin{lstlisting}
# Duration in steps per simulation
simulation_length: 112 
    \end{lstlisting}
\end{description}

\section{Temporal and Contextual Settings}

These parameters anchor the simulation to a specific point in time, which is crucial for sourcing external data such as electricity prices and solar irradiance profiles.

\begin{description}
    \item[\texttt{\textbf{date}}] The \texttt{year}, \texttt{month}, and \texttt{day} parameters set the initial date. The \texttt{random\_day} boolean determines if a new, random date is selected upon each environment reset, facilitating stochastic analysis over different time periods.
    \begin{lstlisting}
year: 2022
month: 1
day: 17
random_day: True
    \end{lstlisting}

    \item[\texttt{\textbf{time}}] The initial \texttt{hour} and \texttt{minute} of the simulation. These typically remain fixed across resets to ensure consistent starting conditions.
    
    \item[\texttt{\textbf{simulation\_days}}] Constrains the simulation to specific day types (\texttt{weekdays}, \texttt{weekends}, or \texttt{both}), allowing for the study of distinct demand patterns.
\end{description}

\section{Stochastic Demand Modeling}

This section governs the arrival and behavior of Electric Vehicles (EVs), which constitute the primary source of flexible load in the simulation.

\begin{description}
    \item[\texttt{\textbf{scenario}}] Defines the archetypal environment (e.g., \texttt{workplace}, \texttt{public}, \texttt{private}), which loads a corresponding statistical model for EV arrival times, departure times, and required energy.
    
    \item[\texttt{\textbf{spawn\_multiplier}}] A scalar value that adjusts the baseline EV arrival rate. A value greater than 1 increases the density of EVs, thereby intensifying the stress on the charging infrastructure and creating more challenging control problems.
    \begin{lstlisting}
scenario: workplace
spawn_multiplier: 5
    \end{lstlisting}
\end{description}

\section{Economic Framework}

These parameters establish the financial incentives and constraints that drive the optimization objective.

\begin{description}
    \item[\texttt{\textbf{discharge\_price\_factor}}] A foundational economic lever for Vehicle-to-Grid (V2G) operations. It defines the remuneration for discharging energy back to the grid as a fraction of the purchasing price. A value less than 1.0 models a realistic bid-ask spread, ensuring economic viability for the grid operator.
    \begin{lstlisting}
# A factor of 0.95 means selling energy yields 95% of the purchasing price.
discharge_price_factor: 0.95
    \end{lstlisting}
\end{description}

\section{Physical Infrastructure}

This section specifies the hardware and topological constraints of the charging network. These are the "hard" constraints that no algorithm can violate without incurring significant penalties.

\begin{description}
    \item[\texttt{\textbf{v2g\_enabled}}] A global boolean flag to enable or disable V2G capabilities for all charging stations.
    
    \item[\texttt{\textbf{number\_of\_charging\_stations}}] The total count of charging points available.
    
    \item[\texttt{\textbf{transformer}}] Defines the properties of the local transformer, most critically its \texttt{max\_power} capacity in kW. This parameter represents the primary bottleneck of the system; exceeding this limit results in an overload condition.
    \begin{lstlisting}
transformer:
  max_power: 100 # in kW
    \end{lstlisting}
    
    \item[\texttt{\textbf{charging\_station}}] Specifies the default electrical properties of a charging station, including maximum current, voltage, and number of phases. These are used to calculate the maximum power per station.
    \begin{lstlisting}
charging_station:  
  max_charge_current: 32 # Amperes
  voltage: 400 # Volts
  phases: 3
    \end{lstlisting}
\end{description}

\section{Exogenous Energy Events}

These parameters introduce external, often uncontrollable, energy flows and grid requests that add realism and complexity to the simulation.

\begin{description}
    \item[\texttt{\textbf{inflexible\_loads}}] Models background energy consumption from sources other than EVs (e.g., building lighting, HVAC). When enabled, this load consumes a portion of the transformer's capacity, reducing the available power for EV charging.
    
    \item[\texttt{\textbf{solar\_power}}] Simulates on-site photovoltaic generation. This introduces a source of low-cost, intermittent energy that intelligent algorithms can leverage to reduce charging costs.
    
    \item[\texttt{\textbf{demand\_response}}] Models a request from the grid operator to curtail power consumption for a specified duration. The \texttt{notification\_of\_event\_minutes} parameter is crucial, as it provides the forecast horizon that advanced control algorithms (like MPC) require to plan and adapt their charging strategies effectively.
\end{description}

\section{Electric Vehicle Fleet Specification}

This section defines the characteristics of the vehicles being charged.

\begin{description}
    \item[\texttt{\textbf{heterogeneous\_ev\_specs}}] A boolean that, if true, populates the simulation with a diverse fleet of EVs with varying battery capacities and charging rates, as defined in the \texttt{ev\_specs\_file}. This enhances simulation realism.
    
    \item[\texttt{\textbf{ev}}] This subsection defines the default properties of a single EV. Key parameters include:
    \begin{itemize}
        \item \texttt{charge\_efficiency} and \texttt{discharge\_efficiency}: Model the energy losses inherent in the charging and discharging processes. Values less than 1.0 are physically realistic and are the source of the \texttt{Q\_lost} metric.
        \item \texttt{desired\_capacity}: Represents the target state-of-charge requested by the user, modeling the fact that not all users require a full 100\% charge.
    \end{itemize}
    \begin{lstlisting}
ev:
  charge_efficiency: 0.95
  discharge_efficiency: 0.95
  desired_capacity: 0.9 
    \end{lstlisting}
\end{description}




\subsection{Dual-Mode Training: Specialists and Generalists}

The new workflow seamlessly manages the training of both "specialist" agents (optimized for a single scenario) and "generalist" agents (robust across multiple scenarios). The behavior is determined by the number of selected scenarios:

\begin{itemize}
    \item \textbf{Single-Domain Specialization:} If only one scenario is selected, the RL agent is trained exclusively on that \texttt{EV2Gym} environment.
    \item \textbf{Multi-Scenario Generalization:} If multiple scenarios are selected, the script automatically utilizes the custom \texttt{MultiScenarioEnv} wrapper. This Gymnasium environment:
    \begin{itemize}
        \item \textbf{Random Selection:} At the start of each training episode, it randomly selects a configuration file and initializes a new \texttt{EV2Gym} environment.
        \item \textbf{Handling Heterogeneous Spaces:} To allow a single neural network to control environments with a varying number of charging stations (and thus different observation and action space sizes), the maximum size (\texttt{MAX\_CS}) across all scenarios is calculated. The returned observation is \textbf{padded} with zeros up to the maximum size (\texttt{max\_obs\_shape}), and the network's action is \textbf{sliced} to the actual size required by the current environment (\texttt{current\_env.action\_space.shape}). This mechanism, supported by the \texttt{CompatibilityWrapper} during evaluation, is crucial for training generalist agents.
    \end{itemize}
\end{itemize}

\subsubsection{Advanced Multi-Scenario Training Strategies}

In addition to random selection, the workflow supports advanced strategies to enhance generalization:

\begin{itemize}
    \item \textbf{Curriculum Learning (\texttt{CurriculumEnv}):} The agent is trained in a predefined sequence of scenarios. The environment progresses to the next curriculum level only after the agent has completed a fixed number of training steps (\texttt{steps\_per\_level}) in the current level. This allows for starting with simpler scenarios and progressing toward complexity.
    \item \textbf{Shuffled Multi-Scenario (\texttt{ShuffledMultiScenarioEnv}):} At the beginning of each "epoch," the list of scenarios is randomly shuffled. The agent runs one full episode on each scenario in this random order before the list is reshuffled for the next epoch. This ensures the agent sees all scenarios in a non-repetitive order within a complete cycle.
\end{itemize}

\subsection{MPC Integration and Approximation}

The workflow integrates both classical MPC and its approximations:

\begin{itemize}
    \item \textbf{Linear MPC:} The \texttt{run\_experiments.py} script utilizes an MPC based on a linear optimization model (\texttt{OnlineMPC\_Solver}).
    \item \textbf{Approximate Explicit MPC:} The scripts \texttt{train\_mpc\_approximator.py} and \texttt{train\_mpc\_approximator\_nn.py} are dedicated to creating an \textbf{Approximate Explicit MPC}. This process:
    \begin{enumerate}
        \item Generates a dataset of samples (state, optimal action) by solving the MPC problem (the oracle) across a large number of random states in different scenarios.
        \item Trains a Machine Learning model (Random Forest in \texttt{train\_mpc\_approximator.py} or a Neural Network in \texttt{train\_mpc\_approximator\_nn.py}) to map the state to the optimal action.
    \end{enumerate}
    This approach drastically reduces runtime computation, transforming a complex optimization problem into a simple model inference, making MPC suitable for real-time control and providing a high-speed performance baseline.
\end{itemize}

\subsection{Rigorous and Reproducible Benchmarking}

The \texttt{run\_benchmark} function in \texttt{run\_experiments.py} is designed to ensure fair and rigorous evaluation:

\begin{itemize}
    \item \textbf{Replay Mechanism:} To compare algorithms under identical conditions, the benchmark first runs a "replay" simulation with a null action, saving the entire sequence of stochastic events (EV arrivals, prices, etc.) to a \texttt{.pkl} file. Subsequently, each algorithm is evaluated by loading and reproducing \textit{exactly} the same event sequence. This eliminates stochastic variability between runs, making the comparison between algorithms highly reliable.
    \item \textbf{Performance Metrics:} Results are aggregated over multiple simulations (\texttt{num\_simulations}) and include key metrics such as:
    \begin{itemize}
        \item Total Profit (â‚¬)
        \item Average User Satisfaction (\%)
        \item Peak Transformer Loading (\%)
        \item Total Battery Degradation (\%), with detail on cyclic loss and calendar loss.
    \end{itemize}
    \item \textbf{Automatic Visualization:} Plotting functions (\texttt{plot\_performance\_metrics}, \texttt{plot\_degradation\_details}) automatically generate bar charts for the key metrics, grouping algorithms by category (heuristics, MPC, RL On-Policy, RL Off-Policy) for clear visual analysis.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%










\subsection{Software Implementation and Project Structure}
\label{sec:software_implementation}
The practical implementation is organized within a modular Python package named \texttt{ev2gym}. This structure promotes code reusability and separation of concerns. High-level experimentation scripts, such as \texttt{run\_experiments.py} and \texttt{train\_mpc\_approximator.py}, reside in the project's root directory and orchestrate experiments by utilizing the core functionalities provided by the \texttt{ev2gym} package.

The key subdirectories within the \texttt{ev2gym} package are:
\begin{itemize}
    \item \texttt{baselines/}: Contains implementations for all non-RL controllers, including rule-based heuristics (in \texttt{heuristics.py}) and all variants of the Model Predictive Controllers (in \texttt{pulp\_mpc.py}).
    \item \texttt{rl\_agent/}: The central location for all Reinforcement Learning logic, containing modules for state vector construction (\texttt{state.py}), the library of available reward functions (\texttt{reward.py}), and the implementation of custom RL algorithms (\texttt{custom\_algorithms.py}).
    \item \texttt{utilities/}: A collection of helper functions and utility classes used across the entire framework.
    \item \texttt{models/}: Designated for storing serialized, pre-trained machine learning models, such as the Random Forest model used by the Approximate-Explicit MPC.
\end{itemize}

This modular software design allows for independent development and testing of different components, such as control algorithms and reward functions, while maintaining a consistent and unified simulation environment.

\section{Core Physical Models}
The simulation's fidelity depends on its detailed, empirically validated models, which are necessary for developing control strategies robust enough for real-world application.

\subsection{EV Model and Charging/Discharging Dynamics}
The framework implements a realistic two-stage charging/discharging model that captures the non-linear behavior of lithium-ion batteries, simulating both the \textbf{constant current (CC)} and \textbf{constant voltage (CV)} phases. Each EV is defined by a comprehensive parameter set: maximum capacity ($E_{max}$), a minimum safety capacity ($E_{min}$), separate power limits for charging and discharging ($P_{ch}^{max}, P_{dis}^{max}$), and distinct efficiencies for each process ($\eta_{ch}, \eta_{dis}$).

\subsection{Battery Degradation Model}
To address the critical issue of battery health in V2G operations, the simulator incorporates a semi-empirical battery degradation model. It quantifies capacity loss ($Q_{lost}$) as the sum of two primary aging mechanisms \cite{orfanoudakis2024ev2gym}: calendar aging and cyclic aging.

\noindent
\begin{itemize}
    \item \textbf{Calendar Aging ($d_{cal}$):} Time-dependent capacity loss, influenced by the battery's average State of Charge (SoC) and temperature ($\Theta$). The formula is:
    \begin{equation}
        d_{cal} = 0.75 \cdot (\epsilon_0 \cdot \overline{SoC} - \epsilon_1) \cdot e^{-\epsilon_2/\Theta} \cdot \frac{t_{days}}{(t_{days}+1)^{0.25}}
    \end{equation}
    
    \item \textbf{Cyclic Aging ($d_{cyc}$):} Wear resulting from charge/discharge cycles, dependent on energy throughput ($E_{exchanged}$), depth-of-cycle (implicitly via $\overline{SoC}$), and the total accumulated charge ($Q_{acc}$). The formula is:
    \begin{equation}
        d_{cyc} = (\zeta_0 + \zeta_1 \cdot |\overline{SoC}-0.5|) \cdot \frac{E_{exchanged}}{\sqrt{Q_{acc}}}
    \end{equation}
\end{itemize}

\noindent
The total capacity loss is the sum $Q_{lost} = d_{cal} + d_{cyc}$. This integrated model enables direct quantification of how different control strategies impact the battery's long-term State of Health (SoH), supporting the training of agents that balance profitability with battery preservation.

\noindent
A key feature of this framework is that the physical parameters for this model ($\epsilon_0, \epsilon_1, \epsilon_2, \zeta_0, \zeta_1, Q_{acc}$) are not fixed. They can be empirically calibrated from real-world experimental data using the provided \texttt{Fit\_battery.py} script, as detailed in Section \ref{sec:sim_architecture}.



\subsection{Reproducible Benchmarking and Evaluation}
To ensure a fair and scientifically valid comparison, the \texttt{run\_benchmark} function implements a rigorous evaluation protocol. For each scenario, it first generates a "replay" file containing the exact sequence of stochastic events (e.g., EV arrivals, energy demands). This exact same sequence is then used to evaluate every algorithm, eliminating randomness as a factor in performance differences. The script runs multiple simulations for statistical robustness, aggregates the mean results, and automatically generates a suite of comparative plots, including overall performance metrics and detailed battery degradation analyses.

\subsection{Interactive Web-Based Dashboard}
\label{sec:streamlit_app}
To complement the command-line-driven workflow, the project includes an interactive web-based dashboard built with the Streamlit library, executed via the \texttt{streamlit\_app.py} script. This graphical user interface (GUI) serves two primary functions, significantly enhancing usability and accessibility for experimentation and results analysis.

\subsubsection{Simulation Orchestrator}
The first part of the dashboard acts as a GUI wrapper for the \texttt{run\_experiments.py} script. It provides a user-friendly web form where users can:
\begin{itemize}
    \item Select which algorithms to benchmark from a multi-select list.
    \item Choose one or more scenarios to test.
    \item Pick a specific reward function for the RL agents from a dropdown menu.
    \item Set simulation parameters, such as the number of evaluation runs.
    \item Toggle optional steps, like running the \texttt{Fit\_battery.py} calibration or enabling RL model training.
\end{itemize}
Upon clicking the "Run Simulation" button, the application constructs the equivalent command-line arguments and executes \texttt{run\_experiments.py} as a subprocess. It captures and displays the console output in real-time on the web page, providing a seamless user experience without requiring direct terminal interaction.

\subsubsection{Results Visualizer}
The second part of the dashboard is a dedicated results browser. It automatically scans the \texttt{results/} directory and presents a list of all completed benchmark runs (organized by timestamp). The user can select a specific benchmark, and the application will find and display all the generated plots (e.g., performance comparisons, battery degradation graphs) directly on the page. This feature allows for quick and convenient inspection and comparison of outcomes from different experiments.

\section{Evaluation Metrics}
To ensure a fair and comprehensive comparison, all algorithms are evaluated against an identical set of pre-generated scenarios through a "replay" mechanism. The \textbf{mean} and \textbf{standard deviation} of performance are calculated across multiple simulation runs. The key metrics include:

\begin{itemize}
    \item \textbf{Total Profit (\$):} The net economic outcome, calculated as revenue from energy sales minus the cost of energy purchases.
    \[
    \Pi_{\text{total}} = \sum_{t=0}^{T_{\text{sim}}} \sum_{i=1}^{N} \left( C_{\text{sell}}(t) P_{\text{dis},i}(t) - C_{\text{buy}}(t) P_{\text{ch},i}(t) \right) \Delta t
    \]
    
    \item \textbf{Tracking Error (RMSE, kW):} For grid-balancing scenarios, this measures the root-mean-square error between the fleet's aggregated power and a target setpoint.
    \[
    E_{\text{track}} = \sqrt{\frac{1}{T_{\text{sim}}} \sum_{t=0}^{T_{\text{sim}}-1} \left( P_{\text{setpoint}}(t) - P_{\text{total}}(t) \right)^2}
    \]
    
    \item \textbf{User Satisfaction (Average):} The fraction of energy delivered compared to what was requested by the user, averaged across all EV sessions. A score of 1 indicates perfect service.
    \[
    US_{\text{avg}} = \frac{1}{N_{\text{EVs}}} \sum_{k=1}^{N_{\text{EVs}}} \min \left(1, \frac{E_k(t_k^{\text{dep}})}{E_k^{\text{des}}} \right)
    \]
    
    \item \textbf{Transformer Overload (kWh):} The total energy that exceeded \\ \noindent 
the transformer's rated power limit. An ideal controller should achieve a value of 0.
    \[
    O_{\text{tr}} = \sum_{t=0}^{T_{\text{sim}}} \sum_{j=1}^{N_T} \max(0, P_j^{\text{tr}}(t) - P_j^{\text{tr,max}}) \cdot \Delta t
    \]
    
    \item \textbf{Battery Degradation (\$):} The estimated monetary cost of battery aging due to both cyclic and calendar effects.
    \[
    D_{\text{batt}} = \sum_{k=1}^{N_{\text{EVs}}} (\text{CyclicCost}_k + \text{CalendarCost}_k)
    \]
\end{itemize}

\section{Simulator Implementation Details}
\label{sec:sim_architecture}
During the analysis and implementation of new metrics, fundamental details about the \texttt{EV2Gym} simulator's architecture emerged, which warrant documentation. The configuration of Electric Vehicles (EVs) and the calculation of their degradation follow a specific logic dependent on a key parameter in the \texttt{.yaml} configuration files.

\subsubsection{Vehicle Definition Modes}
The simulator operates in two distinct modes, controlled by the boolean flag \texttt{heterogeneous\_ev\_specs}:
\begin{itemize}
    \item \textbf{Heterogeneous Mode (\texttt{True}):} In this mode, the simulator ignores the default vehicle specifications in the \texttt{.yaml} file. Instead, it loads a list of vehicle profiles from an external JSON file, specified by the \texttt{ev\_specs\_file} parameter\\ \noindent (e.g., \texttt{ev\_specs\_v2g\_enabled2024.json}). This allows for the creation of a realistic fleet with diverse battery capacities, charging powers, and efficiencies. For instance, the fleet may include a \textbf{Peugeot 208} with a 46.3 kWh battery and a 7.4 kW charge rate, alongside a \textbf{Volkswagen ID.4} with a 77 kWh battery and an 11 kW charge rate. A vehicle is randomly selected from this list for each new arrival event.
    \item \textbf{Homogeneous Mode (\texttt{False}):} In this mode, the external JSON file is ignored. All vehicles created in the simulation are identical, and their characteristics are defined exclusively by the \texttt{ev:} block within the \texttt{.yaml} configuration file. The \texttt{battery\_capacity} parameter in this block becomes the single source of truth for the entire fleet.
\end{itemize}

\subsubsection{Empirical Calibration of the Degradation Model}
A significant enhancement in this work is the move towards a more physically representative and flexible battery degradation model. While the underlying semi-empirical model for calendar and cyclic aging remains, the methodology for parameterizing it has been fundamentally improved, addressing previous inconsistencies.
\noindent
This is achieved through the \texttt{Fit\_battery.py} script, a new utility for empirical model calibration. The script implements the following workflow:
\begin{enumerate}
    \item \textbf{Data Loading:} It loads time-series data from real-world battery aging experiments. The expected data includes measurements of capacity loss over time, along with contextual variables like state of charge (SoC), temperature, and energy throughput.
    \item \textbf{Model Fitting:} Using the \texttt{curve\_fit} function from the SciPy library, the script fits the parameters of the \texttt{Qlost\_model} (which combines calendar and cyclic aging) to the empirical data. This optimization process finds the physical constants (e.g., $\epsilon_0, \zeta_0$) that best explain the observed degradation.
    \item \textbf{Parameter Export:} The script outputs the calibrated parameters. These values can then be used directly in the simulator's configuration, ensuring that the degradation model for a specific EV fleet is grounded in experimental evidence for that battery type.
\end{enumerate}
\noindent
This calibration workflow, integrated optionally into the main \texttt{run\_experiments.py} script, elevates the simulation's fidelity. It allows the framework to move beyond a single, fixed degradation model (previously calibrated for a 78 kWh battery) and enables the creation of high-fidelity digital twins for a wide variety of EV batteries, provided that the necessary experimental data is available.


\section{Simulation Framework Components}
The simulation environment is constructed from a set of modular classes, each representing a key physical or logical component of the EV charging ecosystem. This section details the implementation and mathematical underpinnings of each component.

\subsection{Electric Vehicle Model (\texttt{ev.py})}
The \texttt{EV} class is the most fundamental component, encapsulating the state, physical constraints, and charging behavior of a single electric vehicle. It serves as the primary dynamic element within the simulation.

\subsubsection{State and Attribute Representation}
Each EV instance is defined by a set of static and dynamic attributes that govern its behavior throughout its connection period.
\noindent
\begin{itemize}
    \item \textbf{Static Attributes:} These are defined upon the EV's arrival and remain constant. They include the maximum battery capacity ($E^{\text{max}}_i$), a minimum operational capacity ($E^{\text{min}}_i$), maximum AC charging power ($P^{\text{ch,max}}_i$), maximum discharging power ($P^{\text{dis,max}}_i$), charging efficiency ($\eta_{\text{ch}}$), discharging efficiency ($\eta_{\text{dis}}$), arrival time ($t^{\text{arr}}_i$), and departure time ($t^{\text{dep}}_i$).
    \item \textbf{Dynamic State Variables:} The core state variable is the current energy stored in the battery, denoted as $E_{i,t}$ at time step $t$. This state is updated at every simulation step.
    \item \textbf{Goal-Oriented Attributes:} The EV's objective is defined by its desired energy at departure, $E^{\text{des}}_i$. This is used to calculate user satisfaction.
\end{itemize}

\subsubsection{Charging and Discharging Dynamics}
The model implements a sophisticated two-stage charging process to accurately reflect the behavior of lithium-ion batteries, particularly the transition from the constant current (CC) to the constant voltage (CV) phase.

\paragraph{Two-Stage Charging Model (\texttt{\_charge} method).}
The charging rate is not constant up to full capacity. The model captures the characteristic tapering of current as the battery approaches its maximum charge.
\begin{enumerate}
    \item \textbf{Constant Current (CC) Phase:} When the State of Charge ($SoC_{i,t}$) is below a transition threshold, $SoC^{\text{trans}}$, the battery charges at a constant power. The rate of change of energy is limited by both the pilot signal from the charger, $P^{\text{pilot}}_{i,t}$, and the EV's own maximum charging power, $P^{\text{ch,max}}_i$. The effective charging power is $P^{\text{ch}}_{i,t} = \min(P^{\text{pilot}}_{i,t}, P^{\text{ch,max}}_i)$. The energy evolution is:
    \begin{equation}
        E_{i,t} = E_{i,t-1} + \eta_{\text{ch}} \cdot P^{\text{ch}}_{i,t} \cdot \frac{\Delta t}{60}
    \end{equation}
    where $\Delta t$ is the timescale in minutes.
    
    \item \textbf{Constant Voltage (CV) Phase:} Once $SoC_{i,t}$ exceeds $SoC^{\text{trans}}$, the charging power begins to decrease, even if the pilot signal remains high. The implementation in the \texttt{\_charge} method approximates this tapering effect using an exponential decay function. The model calculates a new transition SoC based on the pilot signal and then computes the new SoC using a formula that ensures a smooth, decaying charge rate as the SoC approaches 100\%. This prevents unrealistic assumptions of constant maximum power charging until the battery is full.
\end{enumerate}

\paragraph{Discharging Model (\texttt{\_discharge} method).}
Discharging is modeled as a linear process, constrained by the EV's maximum discharge power and the battery's minimum energy level. The energy delivered to the grid, $P^{\text{dis}}_{i,t}$, results in a larger energy withdrawal from the battery due to inefficiency:
\begin{equation}
    E_{i,t} = E_{i,t-1} + \frac{P^{\text{dis}}_{i,t}}{\eta_{\text{dis}}} \cdot \frac{\Delta t}{60}
\end{equation}
where $P^{\text{dis}}_{i,t}$ is negative by convention. The operation is constrained such that $E_{i,t} \ge E^{\text{min}}_i$.

\subsubsection{User Satisfaction Metric}
Upon departure at time $t^{\text{dep}}_i$, the performance of the charging service is quantified by a user satisfaction metric, $S_i$. This is defined as the ratio of the final energy level to the desired energy level, capped at 100\%.
\begin{equation}
    S_i = \min\left(1, \frac{E_{i, t^{\text{dep}}_i}}{E^{\text{des}}_i}\right)
\end{equation}
This metric provides a crucial feedback signal for control algorithms, penalizing strategies that fail to meet user requirements.

\subsection{Charging Station Model (\texttt{ev\_charger.py})}
The \texttt{EV\_Charger} class acts as an intermediary between the grid infrastructure and the individual EVs. It manages a collection of charging ports and enforces its own set of physical and operational constraints.

\subsubsection{Role and Attributes}
A charging station (CS) is defined by its number of ports ($N_{\text{ports}}$), its maximum aggregate charging and discharging currents ($I^{\text{max,ch}}_{\text{CS}}$, $I^{\text{max,dis}}_{\text{CS}}$), its operating voltage ($V$), and the number of phases. It serves as a local aggregation point for power and energy.

\subsubsection{Operational Logic (\texttt{step} method)}
At each simulation step, the \texttt{step} method executes the core logic of the charging station:
\begin{enumerate}
    \item \textbf{Action Translation:} It receives a normalized action vector $a_t \in [-1, 1]^{N_{\text{ports}}}$. For each port $j$, it translates the normalized action $a_{j,t}$ into a physical pilot current signal, $I^{\text{pilot}}_{j,t}$.
    \begin{align}
        I^{\text{pilot}}_{j,t} = 
        \begin{cases} 
            a_{j,t} \cdot I^{\text{max,ch}}_{\text{CS}} & \text{if } a_{j,t} > 0 \\
            a_{j,t} \cdot |I^{\text{max,dis}}_{\text{CS}}| & \text{if } a_{j,t} < 0 \\
            0 & \text{if } a_{j,t} = 0
        \end{cases}
    \end{align}
    \item \textbf{EV Interaction:} It passes this pilot current to the \texttt{step} method of the corresponding connected \texttt{EV} instance, which then calculates its actual power exchange based on its internal two-stage model.
    \item \textbf{Power Aggregation:} It aggregates the actual power, $P_{j,t}$, from all its ports to determine its total power exchange with the grid at that time step.
    \begin{equation}
        P_{\text{CS},t} = \sum_{j=1}^{N_{\text{ports}}} P_{j,t}
    \end{equation}
    \item \textbf{Economic Calculation:} It calculates the net profit for the time step based on the aggregated energy and real-time electricity prices ($c^{\text{buy}}_t, c^{\text{sell}}_t$).
    \item \textbf{Departure Management:} It checks for departing EVs, collects their final user satisfaction scores, and frees up the corresponding ports.
\end{enumerate}

\subsection{Transformer Model (\texttt{transformer.py})}
The \texttt{Transformer} class represents a critical piece of grid infrastructure, modeling the point of common coupling for a group of charging stations and other local loads. Its primary function is to enforce an aggregate power limit.

\subsubsection{Model Components}
Each transformer is characterized by its maximum power capacity, $P^{\text{max}}_{\text{TR}}$. It also manages two external time-series data streams:
\begin{itemize}
    \item \textbf{Inflexible Load ($P^{\text{inflex}}_{t}$):} Represents the background power consumption from other sources (e.g., buildings) connected to the same transformer.
    \item \textbf{Solar Power ($P^{\text{PV}}_{t}$):} Represents local photovoltaic generation, which acts as a negative load.
\end{itemize}

\subsubsection{Core Functionality}
The transformer's logic is centered around monitoring its total load and checking for capacity violations.
\noindent
\paragraph{Load Aggregation.} At each time step $t$, the total power flowing through the transformer, $P_{\text{TR},t}$, is the algebraic sum of the inflexible load, the solar generation, and the sum of the power from all charging stations connected to it.
\begin{equation}
    P_{\text{TR},t} = P^{\text{inflex}}_{t} + P^{\text{PV}}_{t} + \sum_{i \in \text{CSs connected to TR}} P_{\text{CS},i,t}
\end{equation}
\paragraph{Overload Detection.} The critical function is \texttt{is\_overloaded}, which returns true if the absolute total power exceeds the transformer's rating. This condition serves as a primary constraint for the control problem.
\begin{equation}
    \text{Overload} \iff |P_{\text{TR},t}| > P^{\text{max}}_{\text{TR}}
\end{equation}
\paragraph{Forecasting with Uncertainty.} The model includes methods (\texttt{generate\_...\_forecast}) to simulate imperfect knowledge of future loads and generation. It creates forecasts by taking the true profiles and adding zero-mean Gaussian noise, where the standard deviation is a configurable percentage of the true value. This allows for the development of robust control strategies that can handle prediction errors.


\subsection{Main Gym Environment (\texttt{ev2gym\_env.py})}
The \texttt{EV2Gym} class is the central orchestrator of the entire simulation. It integrates all the aforementioned physical models into a cohesive whole and exposes it through the standardized \texttt{gymnasium.Env} interface, making it compatible with a wide range of reinforcement learning algorithms.

\subsubsection{Environment Structure and Main Loop}
The class manages the high-level simulation flow.
\noindent
\paragraph{Initialization (\texttt{\_\_init\_\_}).} Upon creation, the environment reads a configuration file to instantiate all the necessary components: it creates the specified number of \texttt{Transformer} and \texttt{EV\_Charger} objects, loads the EV arrival scenarios, and sets up electricity price profiles.
\noindent
\paragraph{Simulation Step (\texttt{step(actions)}).} This method drives the simulation forward by one time step ($\Delta t$). The sequence of operations is as follows:
\begin{enumerate}
    \item It receives a single, flat action vector containing the control signals for every charging port in the entire system.
    \item It slices this vector and passes the appropriate actions to each \texttt{EV\_Charger}'s \texttt{step} method.
    \item This triggers the \texttt{step} methods of all connected \texttt{EV}s, updating their internal states ($E_{i,t}$).
    \item It aggregates the resulting power at each \texttt{Transformer} and checks for overload conditions.
    \item It processes the EV queue, spawning new EVs that are scheduled to arrive at the next time step.
    \item It computes a scalar reward signal using a user-defined reward function.
    \item It constructs the next state observation using a user-defined state representation function.
    \item It checks for termination conditions (e.g., simulation end, constraint violation).
    \item It returns the standard `(observation, reward, terminated, truncated, info)` tuple.
\end{enumerate}
\paragraph{Reset (\texttt{reset}).} This method re-initializes the entire environment to a starting state, allowing for the start of a new simulation episode, which could represent a new day or a different random scenario.


\section{Reinforcement Learning Formulation}
The control problem is formalized as a Markov Decision Process (MDP), defined by the tuple $(S, A, P, R, \gamma)$.

\subsection{State Space ($S$)}
The state $s_t \in S$ is a feature vector providing a comprehensive snapshot of the environment at time $t$. The composition of this vector is crucial for the agent's performance, as it encapsulates all the information available for decision-making. The framework is designed to be flexible, allowing different state representations to be defined in the \texttt{ev2gym/rl\_agent/state.py} module. For the primary task of profit maximization under grid constraints, the \texttt{V2G\_profit\_max\_loads} function is used.

The process of constructing this state vector at each timestep is formally described in Algorithm \ref{alg:state_construction}. It involves gathering temporal, historical, predictive, and physical information from the environment.

\begin{algorithm}[H]
\caption{State Vector Construction (\texttt{V2G\_profit\_max\_loads})}
\label{alg:state_construction}
\begin{algorithmic}[1]
\Function{BuildStateVector}{environment $env$}
    \State \textbf{Initialize:} Empty state list $S_{list} \leftarrow \emptyset$.
    
    \State \Comment{1. Add temporal and historical information}
    \State Append current timestep $env.current\_step$ to $S_{list}$.
    \State Append total power from previous step $env.current\_power\_usage[t-1]$ to $S_{list}$.
    
    \State \Comment{2. Add predictive market information}
    \State Get future charge prices for horizon $H$: $\mathbf{c} \leftarrow env.charge\_prices[t : t+H]$.
    \State Pad $\mathbf{c}$ with the last known value if horizon extends beyond simulation end.
    \State Append $\mathbf{c}$ to $S_{list}$.
    
    \State \Comment{3. Add predictive physical constraints and loads for each transformer}
    \For{each transformer $tr$ in $env.transformers$}
        \State Get forecasts for horizon $H$: $\mathbf{L}, \mathbf{PV} \leftarrow tr.\text{get\_load\_pv\_forecast}(t, H)$.
        \State Get future power limits for horizon $H$: $\mathbf{P}_{\text{lim}} \leftarrow tr.\text{get\_power\_limits}(t, H)$.
        \State Append net load forecast $(\mathbf{L} - \mathbf{PV})$ to $S_{list}$.
        \State Append power limits $\mathbf{P}_{\text{lim}}$ to $S_{list}$.
        
        \State \Comment{4. Add information for each connected EV}
        \For{each charging station $cs$ connected to $tr$}
            \For{each EV slot in $cs$}
                \If{an EV is connected}
                    \State SoC $\leftarrow$ EV.get\_soc().
                    \State $t_{\text{rem}} \leftarrow$ EV.time\_of\_departure - $env.current\_step$.
                    \State Append $[$SoC, $t_{\text{rem}}]$ to $S_{list}$.
                \Else
                    \State Append $[0, 0]$ to $S_{list}$ for padding.
                \EndIf
            \EndFor
        \EndFor
    \EndFor
    
    \State \Return Flatten($S_{list}$) into a single vector $s_t$.
\EndFunction
\end{algorithmic}
\end{algorithm}

The resulting state vector $s_t$ is a concatenation of these components, forming a high-dimensional representation suitable for a deep neural network policy. Mathematically, it can be expressed as:
\[
 s_t = [t, P_{\text{total}}(t-1), \mathbf{c}(t, H), \mathbf{NL}_1(t, H), \mathbf{P}^{\text{lim}}_1(t, H), \dots, \mathbf{s}^{\text{EV}}_1(t), \dots, \mathbf{s}^{\text{EV}}_N(t)]^T
\]
where the components are:
\begin{itemize}
    \item $t$: The current time step, providing temporal context.
    \item $P_{\text{total}}(t-1)$: The aggregated power from the previous time step, serving as a feedback signal of the last action's outcome.
    \item $\mathbf{c}(t, H)$: A vector of \textbf{predicted future} electricity prices over a horizon $H$ (e.g., 20 steps).
    \item $\mathbf{NL}_j(t, H), \mathbf{P}^{\text{lim}}_j(t, H)$: Forecasts for the net inflexible loads (loads minus solar generation) and the power limits for each transformer $j$.
    \item $\mathbf{s}^{\text{EV}}_i(t) = [\text{SoC}_i(t), t^{\text{rem}}_i]$: A sub-vector containing the most critical information for each EV $i$: its current State of Charge and its remaining time until departure ($t^{\text{dep}}_i - t$). If a charger is empty, this sub-vector is padded with zeros to maintain a fixed state size.
\end{itemize}
This state representation is deliberately rich, providing the agent with a multi-faceted view of the system. It combines temporal awareness, feedback from past actions, predictive information about market conditions and physical constraints, and the specific needs of each vehicle. This comprehensive view is essential for enabling the agent to learn sophisticated, forward-looking policies that can effectively balance immediate profit opportunities with long-term obligations to users and the grid.

\subsection{Action Space ($A$)}
The action $a_t \in A$ is a continuous vector in $\mathbb{R}^N$, where $N$ is the number of chargers. For each charger $i$, the command $a_i(t) \in [-1, 1]$ is a normalized value that is translated into a power command:
\begin{itemize}
    \item If $a_i(t) > 0$, the EV is charging: $P_i(t) = a_i(t) \cdot P^{\text{max}}_{\text{charge}, i}$.
    \item If $a_i(t) < 0$, the EV is discharging (V2G): $P_i(t) = a_i(t) \cdot P^{\text{max}}_{\text{discharge}, i}$.
\end{itemize}

\subsection{Reward Function ($R$)}
The reward function $R(t)$ encodes the objectives of the control agent. The framework allows for the selection of different reward functions from the \texttt{reward.py} module to suit various goals. 
\input{Reinforcement_learning}


\input{pulp_mpc}